#ifndef DOCUMENT_H
#define DOCUMENT_H

typedef struct Link {
    int destination_id;
    char* text;
    struct Link* next;
} Link;

typedef struct Document {
    int id;
    char* title;
    char* body;
    Link* links;
    float relevance_score;
    struct Document* next;
} Document;

typedef struct DocumentsList {
    Document* head;
    int size;
} DocumentsList;

Document* documentDeserialize(char* path);
void documentFree(Document* doc);
void documentsListAppend(DocumentsList* list, Document* doc);
Document* documentsListGet(DocumentsList* list, int index);
void documentsListFree(DocumentsList* list);

#endif



#include "document.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define INITIAL_LINKS_CAPACITY 10

Document* documentDeserialize(char* path) {
    FILE* file = fopen(path, "r");
    if (!file) {
        perror("Failed to open file");
        return NULL;
    }

    Document* doc = (Document*)malloc(sizeof(Document));
    if (!doc) {
        fclose(file);
        return NULL;
    }

    // Read document ID
    if (fscanf(file, "%d\n", &doc->id) != 1) {
        free(doc);
        fclose(file);
        return NULL;
    }

    // Read title
    char* title = NULL;
    size_t title_len = 0;
    if (getline(&title, &title_len, file) == -1) {
        free(doc);
        fclose(file);
        return NULL;
    }
    // Remove newline if present
    title[strcspn(title, "\n")] = '\0';
    doc->title = title;

    // Read body
    char* body = NULL;
    size_t body_len = 0;
    char* line = NULL;
    size_t line_len = 0;
    ssize_t read;

    doc->links = NULL;
    doc->relevance_score = 0.0f;

    while ((read = getline(&line, &line_len, file)) != -1) {
        // Check for links in the line
        char* link_start = strchr(line, '[');
        while (link_start) {
            char* link_end = strchr(link_start, ']');
            if (link_end) {
                char* dest_start = strchr(link_end, '(');
                char* dest_end = strchr(link_end, ')');
                if (dest_start && dest_end && dest_start < dest_end) {
                    // Extract link text and destination
                    char* link_text = strndup(link_start + 1, link_end - link_start - 1);
                    char* dest_str = strndup(dest_start + 1, dest_end - dest_start - 1);
                    int dest_id = atoi(dest_str);

                    // Create new link
                    Link* new_link = (Link*)malloc(sizeof(Link));
                    new_link->text = link_text;
                    new_link->destination_id = dest_id;
                    new_link->next = doc->links;
                    doc->links = new_link;

                    free(dest_str);
                }
            }
            link_start = strchr(link_end ? link_end + 1 : link_start + 1, '[');
        }

        // Add line to body
        line[strcspn(line, "\n")] = '\0'; // Remove newline
        if (!body) {
            body = strdup(line);
        } else {
            char* new_body = (char*)malloc(strlen(body) + strlen(line) + 2);
            strcpy(new_body, body);
            strcat(new_body, "\n");
            strcat(new_body, line);
            free(body);
            body = new_body;
        }
    }

    doc->body = body;
    free(line);
    fclose(file);
    return doc;
}

void documentFree(Document* doc) {
    if (!doc) return;
    
    free(doc->title);
    free(doc->body);
    
    Link* current = doc->links;
    while (current) {
        Link* next = current->next;
        free(current->text);
        free(current);
        current = next;
    }
    
    free(doc);
}

void documentsListAppend(DocumentsList* list, Document* doc) {
    if (!list || !doc) return;
    
    if (!list->head) {
        list->head = doc;
    } else {
        Document* current = list->head;
        while (current->next) {
            current = current->next;
        }
        current->next = doc;
    }
    doc->next = NULL;
    list->size++;
}

Document* documentsListGet(DocumentsList* list, int index) {
    if (!list || index < 0 || index >= list->size) return NULL;
    
    Document* current = list->head;
    for (int i = 0; i < index && current; i++) {
        current = current->next;
    }
    return current;
}

void documentsListFree(DocumentsList* list) {
    if (!list) return;
    
    Document* current = list->head;
    while (current) {
        Document* next = current->next;
        documentFree(current);
        current = next;
    }
    list->head = NULL;
    list->size = 0;
}
