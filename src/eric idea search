#ifndef SEARCH_ENGINE_H
#define SEARCH_ENGINE_H

#include "document.h"
#include "reverse_index.h"
#include "graph.h"
#include "query.h"

typedef struct SearchEngine {
    DocumentsList* documents;
    ReverseIndex* reverse_index;
    ReverseIndex* title_index; // Short barrel for titles
    DocumentGraph* graph;
    char** recent_searches;
    int recent_searches_count;
} SearchEngine;

SearchEngine* searchEngineCreate();
void searchEngineLoadDocuments(SearchEngine* engine, char* dataset_path);
void searchEngineRun(SearchEngine* engine);
void searchEngineFree(SearchEngine* engine);

#endif

#include "search_engine.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

#define MAX_RECENT_SEARCHES 3
#define MAX_QUERY_LENGTH 200

SearchEngine* searchEngineCreate() {
    SearchEngine* engine = (SearchEngine*)malloc(sizeof(SearchEngine));
    if (!engine) return NULL;
    
    engine->documents = (DocumentsList*)malloc(sizeof(DocumentsList));
    if (!engine->documents) {
        free(engine);
        return NULL;
    }
    engine->documents->head = NULL;
    engine->documents->size = 0;
    
    engine->reverse_index = reverseIndexCreate(1000);
    engine->title_index = reverseIndexCreate(500);
    engine->graph = documentGraphCreate(100);
    
    engine->recent_searches = (char**)malloc(MAX_RECENT_SEARCHES * sizeof(char*));
    engine->recent_searches_count = 0;
    
    return engine;
}

void searchEngineLoadDocuments(SearchEngine* engine, char* dataset_path) {
    if (!engine || !dataset_path) return;
    
    DIR* dir;
    struct dirent* ent;
    
    if ((dir = opendir(dataset_path)) != NULL) {
        while ((ent = readdir(dir)) != NULL) {
            if (ent->d_type == DT_REG) { // Regular file
                char path[1024];
                snprintf(path, sizeof(path), "%s/%s", dataset_path, ent->d_name);
                
                Document* doc = documentDeserialize(path);
                if (doc) {
                    documentsListAppend(engine->documents, doc);
                    
                    // Add to graph
                    documentGraphAddNode(engine->graph, doc->id);
                    
                    // Process links
                    Link* link = doc->links;
                    while (link) {
                        documentGraphAddNode(engine->graph, link->destination_id);
                        documentGraphAddEdge(engine->graph, doc->id, link->destination_id);
                        link = link->next;
                    }
                }
            }
        }
        closedir(dir);
    }
    
    // Build reverse indexes
    reverseIndexBuild(engine->reverse_index, engine->documents);
    reverseIndexBuild(engine->title_index, engine->documents); // Simplified - would need to only index titles
}

void searchEngineRun(SearchEngine* engine) {
    if (!engine) return;
    
    printf("Welcome to the Search Engine!\n");
    
    char query[MAX_QUERY_LENGTH];
    while (1) {
        // Print recent searches
        if (engine->recent_searches_count > 0) {
            printf("\n******** recent searches *******\n");
            for (int i = 0; i < engine->recent_searches_count; i++) {
                printf("* %s *\n", engine->recent_searches[i]);
            }
            printf("***************\n");
        }
        
        printf("\nSearch: ");
        if (!fgets(query, MAX_QUERY_LENGTH, stdin)) {
            break;
        }
        
        // Remove newline
        query[strcspn(query, "\n")] = '\0';
        
        // Check for empty query
        if (strlen(query) == 0) {
            break;
        }
        
        // Add to recent searches
        if (engine->recent_searches_count >= MAX_RECENT_SEARCHES) {
            free(engine->recent_searches[MAX_RECENT_SEARCHES - 1]);
            for (int i = MAX_RECENT_SEARCHES - 1; i > 0; i--) {
                engine->recent_searches[i] = engine->recent_searches[i - 1];
            }
            engine->recent_searches[0] = strdup(query);
        } else {
            engine->recent_searches[engine->recent_searches_count] = strdup(query);
            engine->recent_searches_count++;
        }
        
        // Process query
        Query* q = queryInit(query);
        if (!q) {
            printf("Error processing query\n");
            continue;
        }
        
        // Search
        DocumentsList* results = searchDocumentsWithQuery(engine->reverse_index, q);
        if (results) {
            // Sort by relevance
            documentsListSortedDescending(results, engine->graph);
            
            // Print results (limit to 5)
            printf("\n");
            int count = 0;
            Document* current = results->head;
            while (current && count < 5) {
                printf("(%d) %s\n", count, current->title);
                printf("---\n");
                
                // Print snippet (simplified)
                if (current->body) {
                    int len = strlen(current->body);
                    if (len > 150) {
                        printf("%.150s...\n", current->body);
                    } else {
                        printf("%s\n", current->body);
                    }
                }
                
                printf("---\n");
                printf("relevance score: %.1f\n\n", 
                       graphGetIndegree(engine->graph, current->id));
                
                current = current->next;
                count++;
            }
            
            printf("[%d results]\n", results->size > 5 ? 5 : results->size);
            
            documentsListFree(results);
            free(results);
        } else {
            printf("No results found\n");
        }
        
        queryFree(q);
    }
}

void searchEngineFree(SearchEngine* engine) {
    if (!engine) return;
    
    documentsListFree(engine->documents);
    free(engine->documents);
    
    reverseIndexFree(engine->reverse_index);
    reverseIndexFree(engine->title_index);
    documentGraphFree(engine->graph);
    
    for (int i = 0; i < engine->recent_searches_count; i++) {
        free(engine->recent_searches[i]);
    }
    free(engine->recent_searches);
    
    free(engine);
}
